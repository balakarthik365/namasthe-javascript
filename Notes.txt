Function statement: A function statement is a block of code with the function key and function name.
    ex: function a(){
        console.log("function statement")
    }
    a();
---------------------------------------------------------------------------------
Function Expression: A function expression is a block of code with the anonymous function that is assigned to a variable.
The difference is hoisting here we see the reference error not a function if we call the function expression variable before the creation.
   ex: var b = function(){
        console.log("function expression")
    }
    b();
---------------------------------------------------------------------------------
Function Declaration: A function declaration is same as function statement.
---------------------------------------------------------------------------------
Anonymous function: A anonymous looks like function statement but has no name. but according to ecma script statement a function should have a name.else it will throw syntax error like function name required
So, anonymous functions are used when functions are used as values like function expression.
    ex: function(){   --> var b = function(){
                                console.log("function expression")
        }                    }   
---------------------------------------------------------------------------------
Named function expression: A named function expression is the function with named function instead of anonymous function that is assigned to a variable
    ex: var c = function xyz(){
        console.log("named function expression")
    }
    c();
    xyz(); //will throw reference error xyz not defined.
---------------------------------------------------------------------------------
Difference between Parameters and Arguments:
Parameters: Which are used as parameters in the function and they are local variables in the function scope.
Arguments: Which are passed as arguments to a function when it is called.
    ex: function sum(x,y){ // x,y are parameters for a function while it created and variables are local in the function scope
        console.log(x+y);
    }
    sum(1,2); // 1,2 are arguments passed to function when called
---------------------------------------------------------------------------------
First class functions: 
Functions are first class citizens.
The ablity to a funciton to use as value is called first class function.
Here functions can be passed as arguments. can return other function also.
    ex: 1.
        const b = function b(param){
        console.log(param)
        }
        b(function(){

        });
        2.
        const b = function b(){
            return function xyz(){

            }
        }
        console.log(b());
---------------------------------------------------------------------------------
Arrow functions: Arrow functions are part of es6 which are introduced while creating the es6 features.
---------------------------------------------------------------------------------
what is callback function in JS?
JS is a synchronous and single-threaded language
callback function: A callback function is a function passed into another function as an argument, 
which is then invoked inside the outer function to complete some kind of routine or action.
setTimeout(function () {
  console.log("hi");
}, 5000);

function x(y) {
  console.log("x");
  y();
}
x(function y() {
  console.log("y");
});
---------------------------------------------------------------------------------
Event listener: Event listener are like events that can be invoked on key press or click or other mouse of keyboard operations attaching a function to it and perform some operations.
Why do we remove event listeners:
When we create event listener it creates a closure and closure remembers the value of outer function once the function is executed.
Event listeners takes some memory space as they are heavy. So, we have to remove event listeners when we are not using them.
Now, once event listeners are removed what ever the values or closures it holds in it gets garbage collected.
---------------------------------------------------------------------------------
Event loop: 
An event loop is like a gate keeper which passes the lines of code in to the GEC.
Its job is to continiosly track the call stack, micro task queues and callback queues

Synchronous lines: these are passed to GEC first

Micro task queue: checks the callback function and pushes the code to the GEC once the callback function is executed with the promises. This gets the higher priority than callback queue and executes before the callback queues
As the callbacks are asynchronous the JS dont wait until they complete the operations and move to next lines.
    ex: console.log("a")
        fetch("https://jsonplaceholder.typicode.com/posts/1").then(function (response) {
        console.log("callback fetch", response);
        });// callback queue created by using webAPI(fetch) and added to GEC as the microtask functions are registered and executed and treated them as the microtask queues.
        console.log("b")
    o/p: a
         b
         button clicked // executed when user clicks the button, untill it stays in the callback queue
Callback/macrotask queue: checks the callback function and pushes the code to the GEC once the callback function is executed with the set timeouts or intervals.
As the callbacks are asynchronous the JS dont wait until they complete the operations and move to next lines. 
Now, call back will check for the asyncronous operations and pass them to callback queue,
based on first in first out whose operations gets completed and each asynchronous operations runs in the GEC under the callstack.
Once the GEC finishes the execution of callback queue the callback from queues also gets vanished
    ex: console.log("a")
        setTimeout(function () {
        console.log("callback settimeout");
        }, 1000);// callback queue created by using webAPI(setTimeout) and added to GEC as the callback functions are registered and executed and treated them as the micro tasks.
        console.log("b")
    o/p: a
         b
         button clicked // executed when user clicks the button, untill it stays in the callback queue
The precedence it follows is 
1. first it will execute the synchronous lines.
2. Next, it will check for the microtasks and executes the first execution that completes from multiple calls and 
3. At last it will check callback queus and executes the first execution that completes from multiple calls. 

The web api are part of browser which gives access to JS engine to use them in GEC(Global Execution Context).
We get this all in the GEC with the global object which is "window".
    ex: window.setTimeout(function test(){ // we can ignore window to use web APIs.

    }, 1000)
Web API:
setTimeout() - timeouts that can be added to piece of code with callbacks
DOM APIs - document. ....
fetch() - to fetch apis
localStorage - to set, use and remove local storage.
console - to print the logs in console
location - to show the webhost location

Final conclusion: Event loop checks the GEC, check the synchronous lines and moniter for microtask and callback quues
and once the GEC is free it adds the 
microtask queue and after completing the microtask queue
it will adds the callback queues to the GEC.

---------------------------------------------------------------------------------
Higher order functions:
A higher order function is a function that takes function as a input or returns a function. 
    ex: function x(){ // callback function
        console.log("x")
    }
    function y(x){ // higher order function
        x()
    }
---------------------------------------------------------------------------------
map(): It itterates over an array and creates a new array.
filter(): It itterates over an array and creates a new array when the condition inside it matches.
reduce(): It itterates over an array and reduce it to single value. It has accumulator, current value and initilizer
accumulator: To accumulate the result value
currentValue: current are the current values in the array 
initilizer: An initial value for the accumulator
